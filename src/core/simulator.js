/**
 * Simulate the game to guess the future
 *
 * @author Daniel Milenkovic
 */
game.core.Simulator = function() {
	/**
	 * The tree is generated by iterating recursively through every move, which is
	 * quite intensive task, since there are so many possibilities.
	 */
	this.generateGameTree = function(board, turn, currentDepth) {
		var scope = this,
			possibleMoves = [];

		if (currentDepth > SIMULATION.DEPTH_LIMIT) {
			return [];
		}

		// Clone chessboard for simulation, since
		// each evaluation should be independent from the previous one.
		// TODO: more efficient implementation
		var simBoard = clone(board);

		var pieces = this.getPiecesOnBoardBySide(simBoard, turn);

		// get possible moves for every piece of current player
		pieces.forEach(function(piece) {
			var moves = [];
			// iterate through every field to check if possible move
			for (var i = 0; i < simBoard.length; i++) {
				var row = simBoard[i];
				for (var j = 0; j < row.length; j++) {
					var newMove = {x: j, y: i, value: 0, nextMoves: []};
					// check if valid move and generate the following moves
					if (game.core.Validator.isValid(newMove, piece, simBoard, turn)) {
						var tempState = scope.simulateMove(newMove, piece, simBoard);
						newMove.value = tempState.value;
						// iterate into the future until depth limit is reached
						newMove.nextMoves = scope.generateGameTree(1 - side, tempState.board, currentDepth + 1);
						moves.push(newMove);
					}
				}
			}

			if (moves.length) {
				possibleMoves.push({
					piece: piece,
					moves: moves
				});
			}
		});

		return possibleMoves;
	}

	this.getPiecesOnBoardBySide = function(board, side) {
		var pieces = [];
		for (var i = 0; i < board.length; i++) {
			var row = board[i];
			for (var j = 0; j < row.length; j++) {
				var piece = row[j];
				if (piece > 0 && piece.side == side) {
					pieces.push(piece);
				}
			}
		}
		return pieces;
	}

	this.simulateMove = function(newPos, piece, board) {
		var simPiece = clone(piece);

		var target = board[newPos.y][newPos.x];
		var value = (target > 0) ? target.value : 0;

		// update chessboard matrix
		board[piece.position.y][piece.position.x] = 0;

		simPiece.position = new Vector(newPos.x, newPos.y);
		board[newPos.y][newPos.x] = simPiece;

		return {
			value: value,
			board: board,
		}
	}
};
