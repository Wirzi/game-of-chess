/**
 * The ultimate chessbot!
 *
 * @author Daniel Milenkovic
 */
function Bot(side, difficulty) {
	this.side = side;
	// todo: difficulty
	this.difficulty = difficulty;
	this.depthLimit = 2;
}

Bot.prototype.init = function(chess) {
	this.chess = chess;

	// reference to chessboard and pieces
	this.board = chess.chessboard.board;
	this.pieces = chess.pieces;
}

Bot.prototype.makeMove = function() {
	var possibleMoves = this.getPossibleMoves(this.side, this.board, 0);
	var gameTree = this.generateGameTree(this.side, this.pieces, this.board, 0);
	console.log(gameTree);
	// var move = evaluateBestMove(gameTree);

	// go by chance ;)
	var move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
	if (chess.makeMove(move.moves[Math.floor(Math.random() * move.moves.length)], move.piece, true)) {
		return true;
	}

	//todo: alphabeta implementation

	return false;
}

/**
 * obsolete as soon as the method gameTree is functional
 */
Bot.prototype.getPossibleMoves = function(side, board, depth) {
	var scope = this,
		possibleMoves = [];

	this.pieces[side].forEach(function(piece, index) {
		var moves = [],
			oldPos = {x: piece.x, y: piece.y};

		// iterate through every field to check if possible move
		for (var i = 0; i < scope.board.length; i++) {
			var row = scope.board[i];
			for (var j = 0; j < row.length; j++) {
				var newMove = {x: j, y: i, value: 0, nextMoves: []};
				// validate move
				if (newMove != oldPos && scope.chess.checkMove(newMove, piece, scope.board)) {
					newMove.value = scope.evaluateMove(newMove);
					moves.push(newMove);
				}
			}
		}

		if (moves.length) {
			possibleMoves.push({
				piece: piece,
				moves: moves
			});
		}
	});

	return possibleMoves;
}

/**
 * The tree is generated by iterating recursively through every move, which is
 * a very intensive task, since there are so many posibillities
 */
Bot.prototype.generateGameTree = function(side, pieces, board, currentDepth) {
	var scope = this,
		possibleMoves = [];

	if (currentDepth > this.depthLimit) {
		return null;
	}

	// clone the chessboard and pieces for simulation, because
	// each evaluation should be independent from the others.
	var simBoard = clone(board),
			simPieces = clone(pieces);

	// get possible moves for every piece of current player
	simPieces[side].forEach(function(piece, index) {
		var moves = [];
		// iterate through every field to check if possible move
		for (var i = 0; i < simBoard.length; i++) {
			var row = simBoard[i];
			for (var j = 0; j < row.length; j++) {
				var newMove = {x: j, y: i, value: 0, nextMoves: []};
				// check if valid move and generate the following moves
				if (scope.chess.checkMove(newMove, piece, simBoard)) {
					var tempState = scope.simulateMove(newMove, piece, simPieces, simBoard);
					newMove.value = tempState.value;
					// iterate into the future until depth limit is reached
					newMove.nextMoves = scope.generateGameTree(1 - side, tempState.pieces, tempState.board, currentDepth + 1);
					moves.push(newMove);
				}
			}
		}

		if (moves.length) {
			possibleMoves.push({
				piece: piece,
				moves: moves
			});
		}
	});

	return possibleMoves;
}

Bot.prototype.simulateMove = function(coords, piece, pieces, board) {
			var value = 0;
			var target = board[coords.y][coords.x];
			if (target) {
				value = target.value;
			}

			// update chessboard matrix
			board[piece.y][piece.x] = 0;
			board[coords.y][coords.x] = piece;

			piece.x = coords.x;
			piece.y = coords.y;

			return {
				value: value,
				board: board,
				pieces: pieces,
			}
}

Bot.prototype.evaluateMove = function() {}
