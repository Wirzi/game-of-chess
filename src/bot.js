/**
 * The ultimate chessbot!
 *
 * @author Daniel Milenkovic
 */
function Bot(side, difficulty) {
	this.side = side;
	this.depthLimit = 2;
}

Bot.prototype.init = function(board) {
	// reference to chessboard and pieces
	this.board = board;
	this.enabled = 1;
};

Bot.prototype.makeMove = function() {
	var gameTree = this.generateGameTree(this.side, this.board, 0);
	var move = this.findBestMove(gameTree);

	var event = new CustomEvent(EVENT.PIECE_MOVED, {
		'detail': {
			'newPos': move.newPos,
			'oldPos': move.oldPos
		}
	});
	window.dispatchEvent(event);
};

/**
 * The tree is generated by iterating recursively through every move, which is
 * quite intensive task, since there are so many possibilities.
 */
Bot.prototype.generateGameTree = function(side, board, currentDepth) {
	var scope = this,
		possibleMoves = [];

	if (currentDepth > this.depthLimit) {
		return [];
	}

	// Clone chessboard for simulation, since
	// each evaluation should be independent from the previous one.
	var simBoard = clone(board);

	var pieces = this.getPiecesOnBoardBySide(simBoard, side);

	// get possible moves for every piece of current player
	pieces.forEach(function(piece) {
		var moves = [];
		// iterate through every field to check if possible move
		for (var i = 0; i < simBoard.length; i++) {
			var row = simBoard[i];
			for (var j = 0; j < row.length; j++) {
				var newMove = {x: j, y: i, value: 0, nextMoves: []};
				// check if valid move and generate the following moves
				if (Validator.checkMove(newMove, piece, simBoard)) {
					var tempState = scope.simulateMove(newMove, piece, simBoard);
					newMove.value = tempState.value;
					// iterate into the future until depth limit is reached
					newMove.nextMoves = scope.generateGameTree(1 - side, tempState.board, currentDepth + 1);
					moves.push(newMove);
				}
			}
		}

		if (moves.length) {
			possibleMoves.push({
				piece: piece,
				moves: moves
			});
		}
	});

	return possibleMoves;
};

Bot.prototype.getPiecesOnBoardBySide = function(board, side) {
	var pieces = [];
	for (var i = 0; i < board.length; i++) {
		var row = board[i];
		for (var j = 0; j < row.length; j++) {
			var piece = row[j];
			if (piece instanceof Piece && piece.side == side) {
				pieces.push(piece);
			}
		}
	}
	return pieces;
};

Bot.prototype.simulateMove = function(newPos, piece, board) {
	var simPiece = clone(piece);

	var target = board[newPos.y][newPos.x];
	var value = (target instanceof Piece) ? target.value : 0;

	// update chessboard matrix
	board[piece.position.y][piece.position.x] = 0;

	simPiece.position = new Vector(newPos.x, newPos.y);
	board[newPos.y][newPos.x] = simPiece;

	return {
		value: value,
		board: board,
	}
};

Bot.prototype.findBestMove = function(gameTree) {
	//todo: alphabeta implementation
	// console.log(gameTree);
	var move = gameTree[Math.floor(Math.random() * gameTree.length)];
	var actualMove = move.moves[Math.floor(Math.random() * move.moves.length)];
	// console.log(actualMove);
	return {
		'newPos': new Vector(actualMove.x, actualMove.y),
		'oldPos': move.piece.position
	}
};

Bot.prototype.findBestMoveByValue = function(moves)
{
	var m = -Infinity;

	for (var i = 0; i < moves.length; ++i) {
		if (moves[i] > m) {
			m = moves[i];
		}
	}

	return m;
};

