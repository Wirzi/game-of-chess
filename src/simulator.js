/**
 * Simulate the game to guess the future
 *
 * @author Daniel Milenkovic
 */
function Simulator() {
	this.depthLimit = 2;
}

/**
 * The tree is generated by iterating recursively through every move, which is
 * quite intensive task, since there are so many possibilities.
 */
Simulator.prototype.generateGameTree = function(side, board, currentDepth) {
	var scope = this,
		possibleMoves = [];

	if (currentDepth > this.depthLimit) {
		return [];
	}

	// Clone chessboard for simulation, since
	// each evaluation should be independent from the previous one.
	var simBoard = clone(board);

	var pieces = this.getPiecesOnBoardBySide(simBoard, side);

	// get possible moves for every piece of current player
	pieces.forEach(function(piece) {
		var moves = [];
		// iterate through every field to check if possible move
		for (var i = 0; i < simBoard.length; i++) {
			var row = simBoard[i];
			for (var j = 0; j < row.length; j++) {
				var newMove = {x: j, y: i, value: 0, nextMoves: []};
				// check if valid move and generate the following moves
				if (Validator.checkMove(newMove, piece, simBoard)) {
					var tempState = scope.simulateMove(newMove, piece, simBoard);
					newMove.value = tempState.value;
					// iterate into the future until depth limit is reached
					newMove.nextMoves = scope.generateGameTree(1 - side, tempState.board, currentDepth + 1);
					moves.push(newMove);
				}
			}
		}

		if (moves.length) {
			possibleMoves.push({
				piece: piece,
				moves: moves
			});
		}
	});

	return possibleMoves;
};

Simulator.prototype.getPiecesOnBoardBySide = function(board, side) {
	var pieces = [];
	for (var i = 0; i < board.length; i++) {
		var row = board[i];
		for (var j = 0; j < row.length; j++) {
			var piece = row[j];
			if (piece instanceof Piece && piece.side == side) {
				pieces.push(piece);
			}
		}
	}
	return pieces;
};

Simulator.prototype.simulateMove = function(newPos, piece, board) {
	var simPiece = clone(piece);

	var target = board[newPos.y][newPos.x];
	var value = (target instanceof Piece) ? target.value : 0;

	// update chessboard matrix
	board[piece.position.y][piece.position.x] = 0;

	simPiece.position = new Vector(newPos.x, newPos.y);
	board[newPos.y][newPos.x] = simPiece;

	return {
		value: value,
		board: board,
	}
};